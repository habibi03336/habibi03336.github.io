---

title: "[책] 데이터베이스를 지탱하는 기술"

date: 2022-4-9 

categories:
    - CS
    - DB
tags:
    - 독서

toc: true
toc_sticky: true
toc_label: "Table of Contents"
toc_icon: "heart"

---


# 1️⃣  책을 읽은 이유

데이터베이스에 관한 기본적인 지식을 챙기고 싶어서 이 책을 읽게 되었다. IT서비스의 중심이 되는 것이 데이터이기 때문에 이를 효율적이고 안정적으로 관리하는 데이터베이스 기술 관련된 지식을 개발자로서 반드시 가지고 있어야 한다고 생각했다. 또한 프로젝트를 진행하면서 어떤 데이터베이스를 사용할지 결정하고, 데이터 모델링을 해야했었다. 하지만 관련 지식이 없어서 명확한 기준 없이 해당 테스크를 수행했었다. 책을 통해 이러한 점을 보완하고 싶었다.

---

# 2️⃣  내용정리

## Chapter 1. 데이터베이스가 없으면 무엇이 곤란한가?

데이터를 저장하고 관리하는데 반드시 데이터베이스를 사용해야하는 것은 아니다. 하지만 IT산업에서 거의 대부분의 데이터(미디어 데이터를 제외한 거의 모든 데이터)는 데이터베이스를 통해서 관리되고 있다.  왜냐하면 데이터베이스 기술이 ‘여러 사람’이 ‘대량의 데이터'를 ‘망가지지 않게' 처리하는데 효과적이기 때문이다. 

## Chapter 2. 인덱스로 고속 엑세스 실현하기

많은 데이터 중에서 자신이 원하는 데이터를 빠르게 찾아내기 위해서 인덱스를 활용할 수 있다. 이 인덱스를 관리하는데 쓰이는 자료구조가 B+Tree이다. B+Tree란 leaf에서만 값을 가지면서, 자식노드를 여러개 가질 수 있는 Tree 구조를 의미한다. 이 구조를 통해 이진탐색(정확히 말하면 다진탐색(?))의 개념으로 인덱스에 접근할 수 있다. 인덱스는 key의 역할로 실제 데이터가 저장된 위치와 바인딩 되어있다. 

고속 엑세스가 되기 위해서 인덱스는 정렬된 상태로 관리되어야 한다. 따라서 데이터가 추가할 때 오버헤드가 발생하게 된다. 그렇기 때문에 데이터 모델링을 할 때 어떤 열에 인덱스를 부여할지 신중하게 접근해야 한다.  또한 인덱스가 부여되지 않은 열에 대한 검색은 해당 테이블의 모든 행을 조회하는 방식으로 밖에 실현될 수가 없다. 따라서 테이블이 큰데 이러한 검색이 실행될 경우 성능이 매우 안 좋을 것이다.

 
## Chapter 3. 테이블 설계와 릴레이션

테이블 설계는 다른 말로 데이터 모델링이라고 한다. 테이블 설계를 잘 하는 것은 중요하다. 어플리케이션이 사용되고 있는 상태에서 테이블 설계를 바꾸는 작업이 어려울 수 있기 때문이다(상당히 큰 오버헤드가 발생할 수 있음). 또한 테이블 설계를 잘 하고, 데이터베이스의 강력한 기능인 테이블 관계를 이용하면 데이터의 중복을 막고 데이터 상 오류를 방지 할 수 있다.

DB 설계이론인 정규화 이론은 속성(열)의 종속관계를 분석하여 여러 테이블의 릴레이션으로 분해해야함을 밝힌다. 그렇지 않으면 삽입 이상, 삭제 이상, 갱신 이상의 문제가 생길 수 있다. 데이터 베이스의 정규성을 확인하는 기준인 제1 정규형~ 제 5정규형, 보이스코드 정규형이라는 기준들이 있다. 책에서는 제 1,2,3 정규형을 설명한다. 테이블을 설계할 때 정규형을 고려하면서 설계해야겠다.

하지만 애플리케이션의 규모가 커서 분산 데이터베이스를 활용할 것이라면 테이블을 정규화 이론에 따라 분해하는 것이 좋지 않다. 왜냐하면 분산 데이터베이스(샤딩) 상황에서는 분해한 테이블을 다시 연결해서 쓰기가 어렵기 때문이다. 

## Chapter 4. SQL문의 특징과 이를 잘 다루는 방법

SQL은 데이터베이스를 조작하는 선언형 언어이다. 기본적으로 INSERT(C), SELECT(R), UPDATE(U), DELETE(D)가 있다. 효율적인 SQL문을 쓰는 것은 중요하다. SQL문에 따라서 성능에 매우 큰 차이가 발생할 수 있기 때문이다. 따라서 적절한 인덱스를 활용하고 있는지 점검하고, EXPLAIN과 같은 데이터베이스 기능을 통해 확인 작업을 가지고, 필요한 경우 분석도구를 활용해 문제를 파악하고 쿼리를 튜닝해야 한다. SQL은 프로그래밍언어가 아니지만 이 한계를 보완할 수 있도록 데이터베이스 차원에서 ‘저장 프로시저' 기능을 제공하기도 한다.

## Chapter 5. 가용성과 데이터의 복제

장애 상황에도 서비스를 제공할 수 있는 것을 ‘가용성'이라고 한다. 데이터베이스 장애의 원인으로는 데이터베이스 소프트웨어의 장애, OS장애, 하드웨어 장애, 조작 실수가 있다. 하드웨어, 특히 저장장치의 장애에 대응하기 위해서 상황에 맞는 RAID 방식에 따라 데이터를 이중으로 관리하는 것이 좋다. 데이터베이스 서버를 여러 대 운영함으로써 가용성을 보장하는 방법이 많이 쓰인다. 이를 복제(Replication)이라고 한다. 복제에는 단방향/비동기 방식, 단방향/준동기화 방식, 단방향/동기 방식이 있다. 단반향이란 마스터에서의 갱신계 SQL을 단방향적으로 슬레이브에게 전달한다는 의미이다. 동기가 의미하는 것은 병목 현상이 일어난 경우나 장애 상황시에 마스터와 슬레이브의 데이터의 동기성이 얼마나 보장되는가이다. 

## Chapter 6. 트랜잭션과 무결성, 무정지성

트랜잭션은 여러 SQL문이나 하나의 SQL문이 여러 열에 대해서 동작할 때 이것을 마치 하나의 명령처럼 처리해주는 기능이다.  예를 들어, 게임에서 캐쉬 아이템을 구매할 경우 캐쉬 보유량을 100 줄이고 보유 아이템을 늘려주어야 한다고 해보자. 이 때 이 두 가지 동작을 마치 하나의 사건처럼, 다른 말로 원자성을 가지도록 처리하는 기능을 ‘트랜잭션’이라고 한다. 이 기능이 유용한 것은 만약 중간에 문제가 생길 때 모든 작업을 원래대로 돌리는 롤백(ROLLBACK)을 할 수 있기 때문이다.  위의 예에서 만약 캐쉬는 100을 이미 줄였는데, 알고보니 아이템의 수량이 제한되어있어서 아이템을 늘리지 못하는 상황이라고 해보자. 트랜잭션 기능이 없다면 이런 상황에서 오류처리를 따로 해줘야 하지만 트랜잭션 기능을 이용하면 데이터베이스가 애초에 이런 작업이 없었던 상태로 ROLLBACK하므로 걱정할 필요가 없다. 또한 트랜잭션 기능을 활용하면 무정지성이 확보된다. 즉 SQL 명령이 실행되고 있을 때 장애가 발생하여도 REDO로그를 활용한 충돌 복구를 통해 장애이전 상태로 복구된다. 

## Chapter 7. 스토리지 기술의 변천과 데이터베이스에 끼치는 영향

64bit OS가 도입되고 메모리의 용량이 크게 늘어나면서 한 대의 서버가 처리할 수 있는 데이터의 양이 크게 늘어났다. 또한 저장 장치가 HDD에서 SDD로 변하면서 저장장치 액세스 비용도 크게 낮아지면서 데이터베이스 성능 향상의 주요 포인트도 바뀌었다. 디스크 I/O가 충분히 빨라지면서 CPU쪽에서 병목현상이 나타나기 시작했고, SQL처리를 위한 문자열 처리, 데이터베이스 연결 처리와 같은 작업의 효율이 아쉬워졌다. NoSQL의 목적 중 하나가 이런 문제를 해결하는 것이다.

## Chapter 8. 데이터베이스 운용 기술의 급소

대규모 데이터베이스를 적절히 운용하는 것은 매우 어려운 일이다. 문제 예방을 위해서는 충분히 검증이된 기술을 사용하는 것이 좋다.(새로운 기술은 작은 프로젝트부터 점진적으로 적용해나가는 것을 추천한다.) 또한 아키텍처를 최대한 단순화해 많은 사람이 문제에 대응할 수 있도록 해야한다. 문제 인지를 빠르게 하기 위해서는 적절한 항목을 모니터링 해야한다. CPU 사용률, 동시 접속 수, 스톨, 초당 SQL 문 실행 횟수, 하드웨어 장애, 디스크 공간 등을 모니터링 해야한다.

## Chapter 9. MySQL로 배우는 데이터베이스 관리

MySQL의 설치, 로그 파일 일기, 설정, 백업/ 복구를 하는 방법을 알려준다.

## Chapter 10. MySQL의 소스 코드를 추적해 보자

오픈 소스 소프트웨어인 MySQL의 소스를 해킹하는 방법을 소개한다. 텍스트 검색 기능을 활용한 정적 분석 방법과 디버깅 기능을 활용한 동적 분석 방법을 제시하며, 소프트웨어 에러에 적극적으로 대응 했던 필자의 사례를 들려준다.

## Chapter 11. 데이터베이스 기술의 현재와 미래

데이터베이스의 참조와 갱신을 블록하지 않고 테이블 스키마를 변경하고 싶은 경우가 있다.  사실 많은 IT서비스에서 서비스 기능 추가, 변경, 삭제가 빈번하게 일어나고 있고, 따라서 테이블 스키마도 동적으로 바뀌어야할 필요가 있다. 이러한 경우 MySQL Cluster와 같은 유료 서비스를 사용할 수 있다. 

혹은 스키마 없는 데이터베이스, 즉 NoSQL을 도입할 수도 있다. NoSQL은 데이터를 JSON이나 XML과 같은 자료구조를 갖춘 문자열로 저장하는 것이다. 또한 NoSQL은 SQL보다 빠르다. 왜냐하면 SQL문의 구문 분석이나 테이블 열기/닫기와 같은 작업이 없기 때문이다. 책에서 MySQL이 초당 10만 쿼리를 처리한다면, memcached와 같은 NoSQL은 30만 쿼리 이상 처리할 수도 있다고 언급한다. 대표적인 NoSQL 데이터베이스인 MongoDB의 경우 자동 샤딩(Sharding)을 지원하는데 이 또한 사업상 큰 이점이라고 언급한다. 샤딩이란 인덱스가 너무 커지는 것을 막기 위해 특정 기준에 따라 데이터를 서로 다른 데이터베이스에 분할하는 것을 의미한다. 

하지만 NoSQL도 단점이 있다. NoSQL은 보통 트랜잭션을 지원하지 않는다. 따라서 장애 발생 시 데이터의 무결성을 보장할 수 없다. 데이터의 무결성이 중요한 경우 NoSQL을 사용하는 것은 위험하다. 그럼에도 불구하고 NoSQL은 몇몇 상황에서 유용하게 쓰인다. RDBMS의 캐시로 memcached를 활용하거나, session 관련 데이터에 활용하기에 좋다. 

## Chapter 12. 빅 데이터 시대의 데이터베이스 설계

“머리속과 실험으로 동작하는 소프트웨어와 현장 서비스에서 실제로 동작하는 소프트웨어가 전혀 다르다는 것을 얼마나 이해할 수 있는가"를 담은 챕터이다. 데이터베이스 선정, 데이터 모델링, 대규모 데이터 취급, 쿼리 및 트랜잭션 튜닝에 대한 필자의 경험을 밝히고 있다.